//Теперь настроим работу полосы с двумя ползунками
//DOUBLE-RANGE
//Выбираем каждую такую полосу на странице
$('.double-range').each(function () { //Для каждой полосы делаем следующее
   const dr = $(this); //сохраняем шкалу выбора в переменную
   const line = dr.find('.line'); //находим в ней сам объект полосы
   let lineRect = line[0].getBoundingClientRect(); //получаем её размеры и расположение
   //Размеры и положение представлено описанным прямоугольником
   //Это объект со свойствами, в которых хранится положение и размеры

   const thumb1 = dr.find('.thumb1'); //находим первый ползунок
   const thumb2 = dr.find('.thumb2'); //второй ползунок
   const thumbs = [thumb1, thumb2]; //складываем их в массив

   const fieldFrom = dr.find('.field_from input'); //поле ОТ
   const fieldTo = dr.find('.field_to input'); //поле ДО

   //в константу сохраним размер экрана, от которого надо менять взаимодействие
   //дело в том что на пк работают события мыши, а на телефоне touch-события
   //для них надо писать отдельный код
   const screenBreak = 500;

   //Теперь, для каждого ползунка определим слушатели (listener)

   //Дело в том что события мыши следуют в таком порядке:
   //1. mousedown
   //2. mousemove
   //3. mouseup
   //Только есть проблема. Когда мы двигаем курсор, браузер отстаёт.
   //Когда мы выходим за пределы ползунка, то он перестаёт двигаться.
   //В итоге получим отрывистое движение, которое очень раздаражет.
   //Чтобы обойти эту проблему я сохраню ссылку на текущий ползунок в window
   //И буду отслеживать движение курсора мыши на всём окне
   //Тогда координаты будут всегда точные и ползунок будет двигаться ровно.

   //Слушатель ждёт какое-то событие, и при срабатывании события вызывает функцию, которую мы привяжем
   thumbs.forEach(thumb => {
      //При нажатии ЛКМ на этот ползунок будет следуюющее
      thumb.on('mousedown', e => { //е - аргумент в котором будет инфа о событии
         //Код ниже работает только на ПК
         //Прикол в том, что событие mousedown иногда работает и на телефоне
         //И это иногда может ломать сайт и вызывать ошибки
         //Так что будет отключать в зависимости от ширины экрана
         if (screen.width > screenBreak) {
            //В общем, если мы нажали на блок, то запомним это
            window.currThumb = thumb;
            thumb.pressed = true; //и добавим ему свойство, что он нажат
         }
      });

      //Ниже представлено взаимодействие через тач события
      //Они работают нормально, поэтому не надо сохранять текущий ползунок в window
      //Но чтобы писать меньше кода я вынес в отдельную функцию, которая работает и на ПК и на мобиле
      //Так что сохраняем и тут для совместимости

      //На ПК нет тач событий так что ограничивающих условий внутри не нужно
      thumb.on('touchstart', e => {
         window.currThumb = thumb;
         thumb.pressed = true;
         //пересчитываю размеры, потому что были косяки при изменении размера страницы
         lineRect = line[0].getBoundingClientRect();
      });
      //Тут мы описываем что делать когда мы твигаем тач
      thumb.on('touchmove', e => {
         //вынес в отдельную функцию, которая получает положение курсора/тача
         handleFieldsToThumbs(event.changedTouches[0].clientX);
      });
      //Когда отпустили тач
      thumb.on('touchend', e => {
         if (!window.currThumb) return;
         window.currThumb.pressed = false; //теперь нам надо пометь что ползунок не нажат
      });
   });

   //функция получает положение курсора/тача по координате Х
   function handleFieldsToThumbs(clientX) {
      function roundToStep(x) {
         //const step = Math.round(lineRect.width * (dr.step / (dr.max - dr.min)));
         const step = dr.step;
         const halfStep = step / 2;

         const startI = x - halfStep < dr.min ? dr.min : x - halfStep,
            stopI = x + halfStep > dr.max ? dr.max : x + halfStep;
         
         let targetI, minDiffer = Infinity;
         for (let i = startI; i < stopI; i++) {
            if (i % step == 0) {
               const differ = Math.abs(x - i);
               if (differ < minDiffer) {
                  minDiffer = differ;
                  targetI = i;
               }
            }
         }
         
         if (targetI === undefined) {
            const middle = (dr.max + dr.min) / 2;
            if (targetI < middle) targetI = dr.min;
            else targetI = dr.max;
         }

         console.log(`step: ${step}; x: ${x}; i: ${targetI}`);
         return targetI;
      }

      //на всякий, чтобы избежать ошибок
      if (!window.currThumb) return; //если нет ползунка то выходим из функции
      if (window.currThumb.pressed) { //если ползунок нажат, опять же на всякий
         // console.log(`${clientX} > ${lineRect.right} ? ${lineRect.width} : ${clientX} - ${lineRect.left}`);

         //Логика.
         //Я могу управлять положением ползунка через CSS свойство left.
         //Когда left=0, то ползунок в начале полосы
         //Когда left=ширине_полосы_в_пикселях, то ползунок в конце полосы
         //Если вычесть из текущего положения курсора (clientX) координаты начала полосы, 
         //то мы узнаему какой величины отступ надо делать.
         //Осталось всё посчитать

         //высчитываем положение ползунка относительно начала полосы
         //Если мы вышли за границы полосы вправо, то ползунок не должен выходить за границу
         //Для этого тернарный оператор, он такой же как в ПХП
         let left = clientX > lineRect.right ? lineRect.width : clientX - lineRect.left;
         //Если же мы ушли далеко влево, то получим отрицательный отступ влево
         //Нам нужно огрничится нулём, так что переопределим
         if (left < 0) left = 0;

         //Можно обратиться к стилям элемента (атрибут style) через свойство style и его свойства
         //Так мы настроим величину отступа слева
         //Обращаемся к первому элемену массива, чтобы снять оболчку jQuery, потому что библиотека надевает методы именно через массив
         window.currThumb[0].style.left = left + 'px'; //кароч просто присавиваем новую величину отступа

         //Ещё я написал методы которые высчитывают числовое значение в зависимости от позиции
         //Они будут рассмотрены позже, в месте их определения
         //Суть в том что они возвращают значение, которое надо складывать в текстовые поля
         let from = roundToStep(Math.round(thumb1.getValueFromPos())); //значения дробные, так что округляем их с помощью встроенного Math API
         let to = roundToStep(Math.round(thumb2.getValueFromPos()));
         //Может быть ситуация, что мы уведём ползунок, который отвечал за верхнюю границу выборки, левее левого
         //Тогда получится что верхняя граница меньше нижней, что приведёт к ошибке
         //В таком случае будем менять позунки местами и оставлять верхнюю границу на месте нижней, а двигать нижнюю

         //Звучит сложно, а по сути просто будем писать меньшее значение от позунка в поле from, а большее в to
         if (to < from) { //так что если у нас противоречие, что поменяем значения местами
            let temp = to; //сделаем с помошью временной переменной
            to = from;
            from = temp;
         }

         if (to > dr.max) to = dr.max;
         if (from < dr.min) from = dr.min;

         //и теперь положим эти значения в поля
         fieldFrom.val(from); //val - это метод библиотеки, который меняет значение текстового поля
         fieldTo.val(to);
      }
   }

   //При движении МЫШКИ тоже работает функция выше
   $(window).on('mousemove', e => {
      if (screen.width > screenBreak) {
         handleFieldsToThumbs(event.clientX);
      }
   });

   //Когда отпустим ЛКМ работаем по аналогии с тач событиями
   $(window).on('mouseup', e => {
      if (screen.width > screenBreak) {
         if (!window.currThumb) return;
         window.currThumb.pressed = false;
      }
   });

   //Добавил фишечку для текстовых полей
   //Чтобы когда мы нажимали клавишу вверх - значение увеличивалось на 1
   //А клавиша вниз - уменьшает на 1
   [fieldFrom, fieldTo].forEach(field => {
      field.on('keydown', e => {
         let val = +field.val();
         if (e.originalEvent.key == 'ArrowUp' && val < dr.max) {
            field.val(val + 1);
         } else if (e.originalEvent.key == 'ArrowDown' && val > dr.min) {
            field.val(val - 1);
         }

         //у ползунков я написал ещё один метод, который меняет их положение в соответствии со значением текстового поля
         //так чтомы можем просто использовать эту функцию, чтобы двигать ползунки
         thumb1.setValue(fieldFrom.val());
         thumb2.setValue(fieldTo.val());
      });
   });

   //Теперь самое интересное - миниинтерфейс по управлению шкалой с двумя ползунками
   //Я создал объект, который потом буду использовать как примесь
   //Примесь - это обычный объект, со свойствами и методами.
   //Потом средствами языка эти свойства и методы копируют (примешивают) другим объектам.
   const interface = {
      //с первых строк много всего сразу
      //свойство датасет генерируется автоматически
      //оно отвечает за атрибуты элемента в формате data-имя="значение"
      //к таким атрибутам можно абратится через датасет
      //то есть фактически мы берём значения атрибутов data-min и data-max
      //[0] - чтобы снять оболочку библиотеки, потому что в оболочке нет свойства dataset
      //+ - унарный плюс (работает с одним операндом)
      //этот плюсик выполняет преобразование строки в число
      min: +dr[0].dataset.min, //таким образом получили числовое значение из атрибута
      max: +dr[0].dataset.max,
      step: +dr[0].dataset.step,
      
      thumb1: thumb1, //ещё запишем ссылки на ползунки сюда
      thumb2: thumb2,

      fieldFrom: fieldFrom, //и ссылки на поля
      fieldTo: fieldTo,
      
      init() { //это метод инит, он будет выполнять начальную настройку интерфейса, его будет вызывать позже
         //Тут мы определим удобные функции для ползунков: 
         //1. передвинуть их в зависимости от нужного значения квадратуры;
         //2. получить значение квадратуры в зависимотси от позиции ползунка.

         //Функция для установки позиции в зависимости от значения
         //Ниже функция присваивается как метод двум ползункам сразу
         //Смотри на это как на присваивание обычного объекта, потому что функция тое объект, помнишь :)
         this.thumb1.setValue = this.thumb2.setValue = function (value) { //получает один аргумент - требуемое значение
            if (typeof value == "string") {
               //функция ниже выполняет преобразование строки в десятичное дробное число
               value = parseFloat(value); //работает немного иначе чем унарный плюс
               //Если мы передадим в value строку типа 'adad', то парсинг строки даст что-то неопределённое
               //NaN или undefined, в любом случае это будет не число
               //Поэтому, если value после парсинга не число и не 0, то вернём null
               //Это вызовет ошибку снаружи и мы сможем понять что делаем что-то не так и найти ошибку
               if (!(value || value === 0)) return null;
               //Иначе, округлим значние
               value = Math.round(value);
               //Если значение выходит за границы, что сведём его к границам
               if (value < dr.min) value = dr.min;
               if (value > dr.max) value = dr.max;
            }
            //Теперь посчитаем отступ слева
            //Для этого нам надо:
            //((положение курсора относительно левого края шкалы) / (максимальное значение)) * (ширину полосы)
            //                    фактически проценты (напр 9/10)                    проценты умножим на максимальную ширину
            //Так мы получим отступ
            let left = (value - dr.min) / (dr.max - dr.min) * lineRect.width;
            //Ну и теперь подвинем сам ползунок на эту позицию
            this.css('left', left + 'px');
         };

         //Метод, который возвращает значение исходя из позиции
         //Двойным присваиванием функции нас уже не удивить :)
         this.thumb1.getValueFromPos = this.thumb2.getValueFromPos = function () {
            //получаем отступ слева, функция ниже получит число из строки, напр строка '12px' станет просто 12, что нам и нужно
            let left = parseInt(this[0].style.left); //используем контекст вызова чтобы получить сам ползунок
            //эту формулу я вывел, выразив на листочке из прошлой формулы value (для подсчёта left в функции выше)
            let value = left * (dr.max - dr.min) / lineRect.width + dr.min;
            return value; //теперь мы получили value и вернём его
         };

         this.fieldFrom.val(this.min);
         this.fieldTo.val(this.max);

         //во время инициализации синхронизируем значения атрибутов и внутренних свойств джеса
         this.thumb1.value = +this.thumb1.attr('data-value');
         this.thumb2.value = +this.thumb2.attr('data-value');

         //теперь установим положение ползунков в соответствии с текстовыми полями
         this.thumb1.setValue(this.fieldFrom.val());
         this.thumb2.setValue(this.fieldTo.val());
      }
   };

   //Примешаем примесь средствами языка
   Object.assign(dr, interface);
   Object.assign(this, interface);
   dr.init(); //теперь мы можем инициализировать интерфейс на нашей шкале с двумя ползунками (у нас такая одна - квадратура)

   //и на всякий запишем ссылку на эту шкалу в свойства объекта window.filters
   //window.filters.doubleRange = dr;
});